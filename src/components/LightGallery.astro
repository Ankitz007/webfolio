---
interface Props {
  selector: string
  options?: Record<string, any>
  asyncInsert?: boolean
  tabFocus?: boolean
}

const {
  selector,
  options = {},
  asyncInsert = false,
  tabFocus = false,
} = Astro.props as Props
---

<light-gallery
  data-selector={selector}
  data-options={JSON.stringify(options)}
  data-async-insert={asyncInsert ? '' : undefined}
  data-tab-focus={tabFocus ? '' : undefined}
>
</light-gallery>

<script>
  import lightGallery from 'lightgallery'
  import type { LightGallery as LightGalleryInstance } from 'lightgallery/lightgallery'
  import lgThumbnail from 'lightgallery/plugins/thumbnail'
  import lgZoom from 'lightgallery/plugins/zoom'

  export class LightGalleryElement extends HTMLElement {
    #gallery: LightGalleryInstance | null = null
    #mutationObserver: MutationObserver | null = null
    #lastViewedImage: HTMLImageElement | null = null

    connectedCallback() {
      const selector = this.dataset.selector || 'img'
      const container = document.querySelector(selector) as HTMLElement | null
      if (!container) return

      let userOptions: Record<string, any> = {}
      try {
        if (this.dataset.options) userOptions = JSON.parse(this.dataset.options)
      } catch (err) {
        console.error('[LightGallery] Failed to parse options:', err)
      }

      const initOrUpdateGallery = () => {
        if (this.#gallery) {
          this.#gallery.refresh()
          return
        }

        // Check if there are images in the container
        const images = container.querySelectorAll('img')
        if (images.length === 0) return

        // Prepare images for lightgallery by wrapping them if needed
        images.forEach((img: HTMLImageElement) => {
          // Skip images that should not be in the gallery
          if (
            img.classList.contains('no-zoom') ||
            img.parentNode?.nodeName === 'A' ||
            img.parentNode?.parentNode?.nodeName === 'A'
          ) {
            return
          }

          // If image is not already wrapped in a link, wrap it
          if (img.parentNode?.nodeName !== 'A') {
            const link = document.createElement('a')
            link.href = img.src
            link.dataset.src = img.src

            // Add size data if available
            if (img.naturalWidth && img.naturalHeight) {
              link.dataset.lgSize = `${img.naturalWidth}-${img.naturalHeight}`
            }

            // Wrap the image
            img.parentNode?.insertBefore(link, img)
            link.appendChild(img)
          }
        })

        // Initialize lightgallery
        this.#gallery = lightGallery(container, {
          plugins: [lgZoom, lgThumbnail],
          speed: 500,
          thumbnail: true,
          animateThumb: true,
          zoomFromOrigin: true,
          allowMediaOverlap: false,
          thumbWidth: 100,
          thumbHeight: '80px',
          thumbMargin: 5,
          subHtmlSelectorRelative: true,
          preload: 2,
          actualSize: true,
          download: true,
          counter: true,
          closable: true,
          swipeToClose: true,
          enableSwipe: true,
          enableDrag: true,
          getCaptionFromTitleOrAlt: false,
          mobileSettings: {
            controls: false,
            showCloseIcon: true,
            download: true,
          },
          controls: true,
          selector: 'a[data-src]', // Target only our wrapped images
          licenseKey: '0000-0000-000-0000', // Use trial key for now
          backdropDuration: 300,
          zoom: true,
          scale: 1,
          ...userOptions,
          ...(this.hasAttribute('data-tab-focus') && {
            onSlideItemLoad: (detail: any) => {
              this.#lastViewedImage = detail.slide.querySelector('img')
            },
            onAfterClose: () => {
              if (this.#lastViewedImage) {
                const el = this.#lastViewedImage.parentNode
                if (el?.nodeName === 'FIGURE') {
                  requestAnimationFrame(() => (el as HTMLElement)?.focus())
                } else {
                  requestAnimationFrame(() => this.#lastViewedImage?.focus())
                }
                this.#lastViewedImage = null
              }
            },
          }),
        })

        // Prevent body scroll when gallery is open
        container.addEventListener('lgAfterOpen', () => {
          document.documentElement.style.overflow = 'hidden'
        })

        container.addEventListener('lgAfterClose', () => {
          document.documentElement.style.overflow = ''
        })
      }

      initOrUpdateGallery()

      // Watch for future DOM changes
      if (this.hasAttribute('data-async-insert')) {
        this.#mutationObserver = new MutationObserver(() => {
          // Debounce the update to avoid excessive calls
          setTimeout(initOrUpdateGallery, 100)
        })
        this.#mutationObserver.observe(container, {
          childList: true,
          subtree: true,
        })
      }
    }

    disconnectedCallback() {
      if (this.#mutationObserver) {
        this.#mutationObserver.disconnect()
        this.#mutationObserver = null
      }

      if (this.#gallery) {
        this.#gallery.destroy()
        this.#gallery = null
      }

      // Restore body scroll
      document.documentElement.style.overflow = ''
    }
  }

  if (!customElements.get('light-gallery')) {
    customElements.define('light-gallery', LightGalleryElement)
  }
</script>
